# Serial Configs
# this is how many bytes are recorded in a buffer before they are transmitted.
batch_size_1: 16
batch_size_2: 100

serial_listener_name: &serial_listener_name serial_listener_one_aux
serial_writer_name: &serial_writer_name serial_writer_one_aux

serial_listener_2_name: &serial_listener_2_name serial_listener_two_aux
serial_writer_2_name: &serial_writer_2_name serial_writer_two_aux

#List of interfaces for system to use, anything you put in this list will be added to the server and by extension the ground station host. 
serial_listener_list:
  - *serial_listener_name
  - *serial_listener_2_name

serial_writer_list:
  - *serial_writer_name
  - *serial_writer_2_name

swp_board_writer: *serial_writer_name

# Location of serial port on Raspberry Pi system
uart_0: /dev/ttyS0
uart_2: /dev/ttyAMA2

# Writer's NOTE
# The Raspberry pi 4b has 5 Uart lines.
# NAME  | TYPE
#_______|_____
# UART0 | PL011
# UART1 | mini UART 
# UART2 | PL011
# UART3 | PL011
# UART4 | PL011
# UART5 | PL011
# NOTE: Each uart has 4 pins assign to it. The first to are TX and RX and the last two are for multi device uart. 
# mini uart does not work with the interface I have set up. However, it would be possible to figure out how to make it work.
# In order to see what pins the uart is using run the following command 'dtoverlay -h uart2'. 
# In order to use the additional uart you first need to enable it, by doing the following. 
#   first: add it to the '/boot/config.txt' try running  vim /boot/config.txt, or nano /boot/config.txt, then add the correct line 
#       to the bottom of the config.txt. It should look something like this dtoverlay=UART3
# Then reboot the pi.
# Then check the /dev/ folder for the new serial over lay. It will probably be something like '/dev/ttyAMA3' or '/dev/ttyS3'. 
# One you find the correct path, that is the path you should pass in to our serial class. (see uart_2 or uart_0)

# Server Configs
hostname: '192.168.50.7'  # get this by running hostname -I
display_name : 'space_weather_probes_aux_serial_#_1'
port: 8010
port_serial_1: 8050
port_serial_2: 8020


#Command packets config
APID_pps: 0x021
APID_Idle: 0x022
APID_Stat: 0x023
APID_Mode: 0x024

pvn: 0
pck_type: 1
sec_header: 0
seq_flags: 3

mask_pvn: 0b111
mask_pck_type: 0b1
mask_sec_header: 0b1
mask_APID_1: 0b11100000000
mask_APID_2: 0b00011111111
mask_seq_flags: 0b11
mask_packet_count_1: 0b11111100000000
mask_packet_count_2: 0b00000011111111
mask_packet_len_1: 0xFF00
mask_packet_len_2: 0x00FF

# Sensor configs
sensor_config_dict:
  # This dictionary holds all the sensors configuration, NOTE: the key must match the self.__name variable in the sobj_<sensor> object. 
  # NOTE: The key here becomes part of a file name so make sure you use valid chars in the name. 
  gps_board:
      # This dictionary tells the GPS sensor how to configure itself.
      tap_request: [*serial_listener_2_name]  # Index in the list can be the name of a serial listener or any sensors whose data you want to listen to or None (Example for none: None) 
      serial_writer: *serial_writer_2_name
      publisher: 'yes'
      publish_data_name: 'gps_packets'  # NOTE: NOT used right now
      passive_active: 'passive'  # Passive sensors only publish when they receive then process data, active sensors always publish on an interval.
      interval_pub: 'NA'  # We are not using this param because we are a passive publisher, however if the sensor is active we will need to set this interval to the desired rate. 
      Sensor_data_tag: 0x24  # Hexadecimal representation of '$' This parameter is for the sensor class to search data from the tag, whether it comes from the serial line or from other sensors on the system.
      # Binary tag representing the data terminator used by the sensor.
      # Modify this tag to match the data terminator of additional sensors.
  Sensor_terminator_data_tag: 0x0D0A  # Hexadecimal representation of '\r\n'
